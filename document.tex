% Vorlage für eine Bachelorarbeit
% Siehe auch LaTeX-Kurs von Mathematik-Online
% www.mathematik-online.org/kurse
% Anpassungen für die Fakultät für Mathematik
% am KIT durch Klaus Spitzmüller und Roland Schnaubelt im Dezember 2011

\documentclass[11pt,a4paper,titlepage]{scrartcl}
% scrartcl ist eine abgeleitete Artikel-Klasse im Koma-Skript
% zur Kontrolle des Umbruchs Klassenoption draft verwenden

\usepackage{array}
% die folgenden Packete erlauben den Gebrauch von Umlauten und ß
% in der Latex Datei
\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc} %  Alternativ unter Windows
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage[babel,german=quotes]{csquotes}
\usepackage[pdftex]{graphicx}
\usepackage{latexsym}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[style=alphabetic,backend=biber]{biblatex}
\usepackage{pdflscape}
\usepackage{colortbl}
\usepackage{color}
\bibliography{bib/Quellen}

\usepackage[footskip=1.5cm, left=2.5cm, right=2.5cm, top=2.5cm, bottom=3.5cm]{geometry}

% Definieren von versch. Farben für Tabellenzellen
\definecolor{grey}{rgb}{0.85,0.85,0.85}
\definecolor{lightgrey}{rgb}{0.95,0.95,0.95}

% Abstand obere Blattkante zur Kopfzeile ist 2.54cm - 15mm
\setlength{\topmargin}{-15mm}
\usepackage[onehalfspacing]{setspace}

% Umgebungen für Definitionen, Sätze, usw.
% Es werden Sätze, Definitionen etc innerhalb einer Section mit
% 1.1, 1.2 etc durchnummeriert, ebenso die Gleichungen mit (1.1), (1.2) ..

\newtheorem{Satz}{Satz}[section]
\newtheorem{Definition}[Satz]{Definition}     
\newtheorem{Lemma}[Satz]{Lemma}	
                  
\numberwithin{equation}{section} 

% einige Abkuerzungen
\newcommand{\C}{\mathbb{C}} % komplexe
\newcommand{\K}{\mathbb{K}} % komplexe
\newcommand{\R}{\mathbb{R}} % reelle
\newcommand{\Q}{\mathbb{Q}} % rationale
\newcommand{\Z}{\mathbb{Z}} % ganze
\newcommand{\N}{\mathbb{N}} % natuerliche

\title{Bachelorarbeit}
\author{Andre Weinkötz (14985714)}
\date{15. Februar 2018}


\begin{document}
  % Keine Seitenzahlen im Vorspann
  \pagestyle{empty}

  % Titelblatt der Arbeit
  \begin{titlepage}

\begin{center}
	\includegraphics[scale=0.20]{img/hm-logo.eps}
\end{center}
 \bigskip

 \begin{center} \large 
    
    Bachelorarbeit im Studiengang B.Sc. Wirtschaftsinformatik
    \vspace*{2.5cm}
\end{center}
\begin{center}
	    {\huge Realisierung einer bidirektionalen Chat-Anwendung durch HTML5 WebSockets mit Java und Angular 4 zum Einsatz im seminaristischen Kontext}
	% Echtzeit-Anwendungen im Web durch WebSockets
\end{center}

    
    \vspace*{2.0cm}
 \begin{center}
    Andre Weinkötz \bigskip
    
    

    15. Februar 2018
    \vspace*{2.5cm}
    
    

    Fakultät für Informatik und Mathematik \\
	Hochschule München\bigskip
	
	Betreuer: Prof. Dr. Mandl 
	
	
  \end{center}
\end{titlepage}

\newpage
\section*{Abstract}
\addcontentsline{toc}{section}{Abstract}
Hier steht am Ende was genau eigentlich mit dem Unsinn hier erreicht werden soll.
\newpage
  % Inhaltsverzeichnis
 \tableofcontents

\newpage
%\textbf{ABSTRACT}
%\newpage
  % Ab sofort Seitenzahlen in der Kopfzeile anzeigen
  \pagestyle{headings}

\section{Einleitung}\label{sec:Einleitung}
Die Anforderungen an Webanwendungen haben sich in den vergangenen Jahren stark verändert. Mobile Geräte wie Smartphones oder Tablets ersetzen stationäre Systeme, Webanwendungen sollen zur Kollaboration eingesetzt werden und Buchungssysteme oder Finanzanwendungen verlangen die Bearbeitung tausender Anfragen mit minimaler Verzögerung. Das Hypertext Transfer Protocol (HTTP) bietet hier keine zufriedenstellende Lösung. Um den Anforderungen an moderne Webanwendungen gerecht zu werden, spezifizierten das World Wide Web Consortium (W3C) und die Internet Engineering Taskforce (IETF) das WebSocket-Protokoll mit zugehöriger JavaScript-API. \\

\noindent Die Entwickler des WebSocket Protokolls machten es sich zur Aufgabe, einen Mechanismus zu schaffen, der es browserbasierten Anwendungen ermöglicht bidirektional zu kommunizieren ohne dabei auf mehrere HTTP Verbindungen zu öffnen \autocite{fette_websocket_2011}. Dabei sollte auf zusätzliche Methoden - wie beispielsweise den Einsatz von XMLHttpRequests, iframes oder long polling - verzichtet werden.

\newpage
\section{Das WebSocket Protokoll}\label{sec:WebSocketProtokoll}
Die Arbeit an der Spezifikation des WebSocket Protokolls begann bereits 2009, als es von Google in Zusammenarbeit mit Apple, Microsoft und Mozilla im Rahmen ihrer Kooperation WHATWG\footnote{Web Hypertext Application Technology Working Group unter: www.whatwg.org} der Internet Engineering Task Force (IETF) vorgeschlagen wurde. Bis Mai 2010 wurden noch zahlreiche Verbesserungen hinzugefügt, bis es schließlich in Version 76 \autocite{hickson_websocket_2010} im August 2010 an die BiDirectional or Server-Initiated HTTP (HyBi) Task Force der IETF zur Weiterentwicklung übergeben wurde \autocite{fette_websocket_2010}. Neben vielen anderen Fortschritten wurde das Protkoll um die Möglichkeit erweitert binäre Dateien auszutauschen, sowie Sicherheitslücken geschlossen, die in Verbindung mit Proxy-Servern entstehen konnten. Im Dezember 2010 wurde das WebSocket Protokoll von der IETF zu dem Request for Comment (RFC) 6455 erklärt \autocite{fette_websocket_2011}. Dieser definiert auf über 70 Seiten neben dem Lebenszyklus und den verschiedenen Frames der WebSockets noch zahlreiche weitere technische Details und Defintionen. In diesem Kapitel sollen die wichtigsten Grundlagen der Protokollspezifikation dargelegt werden.
\subsection{WebSocket-Frames}\label{subsec:wsFrames}
Die Spezifikation eines WebSocket-Frames sieht eine Zweiteilung vor, wie sie bei Protokollnachrichten üblicherweise vorgenommen wird. Ein WebSocket-Frame besteht demnach aus einem Header Bereich der Kontrolldaten enthält, sowie dem Payload, welcher die Nutzdaten beinhaltet.\vspace{2mm}
\begin{figure}[ht] \label{fig:wsFrame}
	\begin{center}
		\includegraphics[scale=1.25]{img/frame.pdf}
		\caption{Vereinfachte Darstellung eines WebSocket Frames}
	\end{center}
\end{figure}
Anhand des Aufbaus ist leicht erkennbar, dass die Kommunikation über WebSockets mit deutlich geringeren Paketgrößen arbeiten kann als HTTP. Eine Nachricht mit einfacher Längenangabe, die von Server zu Client geschickt wird, erzeugt durch ihren Header lediglich einen Overhead von zwei Byte. Da WebSocket-Frames auf umgekehrtem Weg zusätzlich noch maskiert werden müssen, entspricht die minimale Länge eines clientseitigen Frames sechs Byte . Im Vergleich dazu beträgt der Overhead bei einer einfachen GET-Anfrage über HTTP/1.1 beim Aufruf des Hosts unter cs.hm.edu 35 Byte. Die Angabe des Hostnamens in HTTP/1.1 ist obligatorisch und trägt maßgeblich zur Größe des HTTP-Frames bei \autocite[128]{leach_hypertext_1999}. 

\subsubsection{Header-Felder}\label{subsubsec:wsHeader}
Im nachfolgenden Abschnitt werden die Felder sowie deren jeweilige Aufgabe detailliert erläutert:

\begin{description}
	\item[FIN (1 Bit)] Das FIN-Flag gibt an, ob es sich bei dem empfangenen Frame um ein Fragment handelt. Kann der Payload nicht auf einmal übertragen werden, so wird die Übertragung über mehrere Frames gesteuert. Das FIN-Flag aller unvollständigen Fragmente weist den Wert 0 auf, wohingegen das finale Fragment mit einer 1 gekennzeichnet ist. Wenn alle Nutzdaten mit einem einzigen Frame übertragen werden können, so trägt dessen FIN-Flag ebenfalls den Wert 1.
	\item[RSV1, RSV2, RSV3 (jeweils 1 Bit)] Diese Flags sind für zukünftige Implementierung reserviert und finden aktuell keine standardisierte Anwendung. Daher tragen sie meist den Wert 0. Ist eines dieser Flags gesetzt und die empfangende Stelle hat keine Erweiterung, welches das jeweilige Flag interpretieren kann, so muss die WebSocket-Verbindung geschlossen werden \autocite[27]{fette_websocket_2011}.
	\item[opcode (4 Bit)] Das opcode-Feld enthält die Angabe wie der Payload zu interpretieren ist. Neben den sogenannten Datenframes bzw. Non-Control-Frames, welche die Art der übertragenen Daten kennzeichnen, sind Control-Frames definiert, die zur Steuerung und Überprüfung der Verbindung verwendet werden. Wird ein unbekannter Opcode empfangen, so wird die WebSocket-Verbindung geschlossen.
	\begin{itemize}
		\item \textbf{0x0} definiert ein Fortsetzungs-Frame
		\item \textbf{0x1} definiert ein Text-Frame
		\item \textbf{0x2} definiert ein Binary-Frame
		\item \textbf{0x3-7} reserviert für weitere Non-Control-Frames
		\item \textbf{0x8} definiert ein Verbindung beenden-Frame
		\item \textbf{0x9} definiert ein Ping-Frame
		\item \textbf{0xA} definiert ein Pong-Frame
		\item \textbf{0xB-F} reserviert für weitere Control-Frames
	\end{itemize}
	\item[MASK (1 Bit)] Ist das MASK-Flag gesetzt, so ist der Payload maskiert. Frames, die clientseitig initiert wurden, müssen maskiert sein, wohingegen serverseitige Frames keine Maskierung vornehmen dürfen. Der verwendete Masking-Key muss im gleichnamigen Header-Feld hinterlegt werden.
	\item[payload length (7 Bit)] Hier wird die Länge der Nutzdaten angegeben. Sind diese nicht größer als 125 Bytes, so können sie mit nur einem Frame übertragen werden. Nutzdaten mit einem höheren Speicherplatzbedarf werden je nach Größe mit dem Wert 126 bzw. 127 angegeben. Diese Angaben führen zur Verwendung des Header-Felds \textit{Extended payload length}.
	\item[Extended payload length (16 Bit oder 64 Bit)] Überschreitet die Länge des Payloads 125 Byte, so wird dieses Feld verwendet. Je nach Wert im Header-Feld \textit{payload length} umfasst die \textit{Extended payload length} zwei Byte oder acht Byte. Dementsprechend beträgt die maximale Länge der Nutzdaten in einem WebSocket-Frame $2^{64} - 1$ Byte \autocite[41]{gorski_websockets_2015}
	\item[Masking Key (0 oder 32 Bit)] Ein Frame, der von einem Client an einen Server gesendet wird, muss mit einem 32-Bit Schlüssel maskiert werden. Dieser wird vom Client generiert und im gleichnamigen Header-Feld abgelegt. Nachrichten, die von einem Server an einen Client gesendet werden, enthalten dieses Feld nicht.
	\item[data (n Byte)] Hier befinden sich die eigentlichen Nutzdaten. Ihre Größe wird in den entsprechenden Längenfeldern des Headers hinterlegt. Werden lediglich Steuerungsinformationen übertragen, wird kein Payload mitgesendet.
\end{description}

\subsubsection{Non-Control-Frames}\label{subsubsec:wsNCFrames} 
Durch das Header-Feld \textit{opcode} wird die Art der Nutzdaten angegeben. Es können sowohl textbasierte Daten als auch Binärdaten übertragen werden. Bei der Kommunikation über WebSockets gibt es hier einige zusätzliche Mechanismen, die für den fehlerfreien Ablauf einer Übertragung notwendig sind. Der folgende Abschnitt handelt von der bereits aus anderen Protokollen bekannten Fragmentierung, die WebSocket-Frames zur sequentiellen Übertragung unvollständiger Daten nutzt sowie der aufgrund von Sicherheitsproblemen eingeführten Maskierung clientseitig initierter Nachrichten.

\subsubsection*{Fragmentierung}\label{subsubsec:wsFragment}
In Abschnitt 5.4. des RFC6455 ist die Fragmentierung von WebSocket-Frames beschrieben. Primäre Anwendung erfährt dieses Verfahren, wenn die Daten zum Zeitpunkt der Übertragung noch nicht vollständig vorliegen oder nicht zwischengespeichert werden können. Wird die vom Server oder einer vermittelnden Stelle festgelegte Puffergröße überschritten, so wird ein Nachrichtenfragment mit dem Inhalt des Puffers gesendet \autocite[32]{fette_websocket_2011}.\\

\noindent Folgende Grundsätze müssen bei der Fragmentierung beachtet werden. Erweiterungen werden hierbei außer Acht gelassen:
\begin{itemize}
	\item Unfragmentierte Nachrichten werden mit einem einzelnen Frame übertragen (FIN-Bit $=$ 1,  opcode $\neq$ 0)  
	\item Die Übertragung fragmentierter Nachrichten erfolgt über mindestens einen Frame mit FIN-Bit $=$ 0 und opcode $\neq$ 0 und wird mit einem Frame FIN-Bit $=$ 1 und opcode $\neq$ 0 abgeschlossen. Die Summe der Payloads aller Fragmente entspricht dem Payload eines Einzelframes bei entsprechender Puffergröße.
	\item Control-Frames (Abschnitt \ref{subsubsec:wsCFrames}) dürfen nicht fragmentiert werden. Sie können zwischen der Übertragung einer fragmentierten Nachricht gesendet werden, um beispielsweise die Latenzzeit eines Pings möglichst gering zu halten. Die Verarbeitung zwischengesendeter Control-Frames muss von allen Endpunkten unterstützt werden.
	\item Der Empfänger muss die Fragemente einer Nachricht in der gleichen Reihenfolge erhalten, in welcher sie vom Sender aufgegeben wurden.
	\item Vermittler dürfen an der Fragmentierung keine Änderungen vornehmen, falls eines der RSV-Bits gesetzt ist und dessen Bedeutung dem Vermittler nicht bekannt ist.
\end{itemize}

\noindent Daraus folgt, dass die Verarbeitung sowohl fragmentierter als auch unfragmentierter Nachrichten von allen Endpunkten unterstützt werden muss. Da Control-Frames nicht fragmentiert werden dürfen, können Fragmente lediglich von den Typen Text, Binary oder einem der reservierten opcodes (0x3-7) sein. Die Angabe des Typs erfolgt durch den opcode des ersten Fragments. Alle weiteren Fragmente tragen den opcode 0x0, der dem Empfänger mitteilt, dass die empfangenen Nutzdaten an den Payload des vorangegangen Frames angehängt werden sollen \autocite{shepherd_writing_2017}.
\subsubsection*{Maskierung}\label{subsubsec:wsMasking}
WebSocket Frames, von einem Client zu einem Server gesendet, müssen maskiert werden. Dieser Mechanismus war im ursprünglichen Draft für das WebSocket Protokoll nicht vorgesehen. In Folge einer Untersuchung durch eine Gruppe von Forschern rund um ein Team der Carnegie Mellon Universität wurden Sicherheitslücken in dem Konzept aufgedeckt. Bei der Verwendung  transparenter Proxy-Server konnten sie durch deren fehlerhafte Implementierung des, bei dem Aufbau einer WebSocket Verbindung genutzten, \textit{Upgrade} Mechanismus den Cache des Proxies infizieren \autocite{huang_talking_2011}. Daraufhin wurde der Draft überarbeitet und um die Maskierung über eine bitweise XOR Verknüpfung ergänzt. \\

\noindent Da der zur Maskierung des Payloads verwendete Schlüssel im Frame enthalten ist, steht hier nicht die Vertraulichkeit der gesendeten Daten im Vordergrund. Vielmehr sollen Proxy-Server daran gehindert werden, den Inhalt des Payloads zu lesen. Somit wird verhindert, dass Angreifer den Payload manipulieren und diesen für einen Angriff gegen einen Proxy einsetzen können \autocite{gorski_websockets_2015}.  Im Folgenden soll der Ablauf der Maskierung einer Textnachricht an einem Beispiel verdeutlicht werden:\\

\noindent Zunächst wählt der Client einen bisher nicht verwendeten 32 Bit Schlüssel aus, der zur Maskierung verwendet werden soll. Die Nachricht, die maskiert werden soll lautet "cs.hm.edu", konvertiert in hexadezimale Darstellung "63 73 2e 68 6d 2e 65 64 75". Als Schlüssel wird "3c 2e 3f 4a" verwendet. Dieser wird nun zyklisch auf den zu maskierenden Payload mit der XOR-Operation angewendet.\\

\begin{table*}[ht]
	\begin{center}
	\begin{tabular}{|l|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|}
		\hline
		Unmaskierte Bytes &  63 &  73 & 2e &68 &6d &2e &65 &64& 75 \\ \hline
		Operator &	$\oplus$ &$\oplus$&$\oplus$ &$\oplus$ &$\oplus$ &$\oplus$ &$\oplus$&$\oplus$ &$\oplus$ \\ \hline
		Schlüssel &  \cellcolor{lightgrey}3c &  \cellcolor{lightgrey}2e & \cellcolor{lightgrey}3f & \cellcolor{lightgrey}4a &\cellcolor{grey}3c & \cellcolor{grey}2e &\cellcolor{grey}3f &\cellcolor{grey}4a& \cellcolor{lightgrey}3c \\ \hline
		Maskierte Bytes &  5f &  5d & 11 & 22 &51 &00 &5a &2e& 49 \\ \hline
	\end{tabular}
	\caption{Maskierung durch bitweise XOR-Verknüpfung}\label{tbl:wsMasking}
		\end{center}
\end{table*}
\vspace{-3mm}
\noindent Die maskierte Nachricht wird mit dem Schlüssel in dem WebSocket-Frame abgelegt. Der Server kann diese nach dem Empfang durch erneute Anwendung der selbstinversen XOR-Operation demaskieren \autocite{gorski_websockets_2015}.

\begin{table*}[ht]
	\begin{center}
		\begin{tabular}{|l|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|>{\centering\arraybackslash}p{0.5cm}|}
			\hline
			Maskierte Bytes &  5f &  5d & 11 & 22 &51 &00 &5a &2e& 49 \\ \hline
			Operator &	$\oplus$ &$\oplus$&$\oplus$ &$\oplus$ &$\oplus$ &$\oplus$ &$\oplus$&$\oplus$ &$\oplus$ \\ \hline
			Schlüssel &  \cellcolor{lightgrey}3c &  \cellcolor{lightgrey}2e & \cellcolor{lightgrey}3f & \cellcolor{lightgrey}4a &\cellcolor{grey}3c & \cellcolor{grey}2e &\cellcolor{grey}3f &\cellcolor{grey}4a& \cellcolor{lightgrey}3c \\ \hline
			Unmaskierte Bytes &  63 &  73 & 2e &68 &6d &2e &65 &64& 75 \\ \hline
			Nachricht & c &s&.&h&m&.&e&d&u\\ \hline
		\end{tabular}
		\caption{Demaskierung durch bitweise XOR-Verknüpfung}\label{tbl:wsDemasking}
	\end{center}
\end{table*}

\noindent Die Übertragung von Server zu Client darf hingegen nicht maskiert werden. Empfängt ein Server eine unmaskierte bzw. ein Client eine maskierte Nachricht, so muss in beiden Fällen die Verbindung geschlossen werden. Dabei kann der im RFC6455 spezifierte Statuscode \textit{1002 (protocol error)} beim Verbindungsabbau angegeben werden \autocite[26]{fette_websocket_2011}.

\subsubsection{Control-Frames}\label{subsubsec:wsCFrames}

\subsection{WebSocket Lifecycle}\label{subsec:wsLifecycle}
\subsubsection{Verbindungsaufbau}\label{subsubsec:wsOpen}
\subsubsection{Datentransfer}\label{subsubsec:wsData}
\subsubsection{Verbindungsabbau}\label{subsubsec:wsClose}

\subsection{Vor- und Nachteile gegenüber Request}

\section{Die WebSocket API}\label{sec:WebSocketAPI}
\subsection{Client-seitige Implementierung}
\subsection{Server-seitige Implementierung}

\section{Fachliche Anforderungen}
\subsection{Analyse des DaKo-Frameworks}
\subsection{Anforderungen an WebSocket-Chat}
\subsection{Prototypische Implementierung}

\section{Technische Anforderungen}
\subsection{Entwurf des WebSocket-Chats}
\subsection{Vergleich der Implementierungsformen}
\subsection{Implementierung des WebSocket-Chats}

\section{Evaluation}
\subsection{Test-Umgebung}
\subsection{Leistungsanalyse WebSocket-Chat}

\section{Zusammenfassung und Ausblick}
\subsection{Einsatzgebiete}
% Unterschrift (handgeschrieben)

\newpage
\pagenumbering{Roman}
\printbibliography

%\newpage
%\listoffigures
%\listoftables

\end{document}
